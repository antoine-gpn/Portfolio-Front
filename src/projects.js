import goweb from "./assets/goweb.png";
import snake from "./assets/snake.png";
import portfolio from "./assets/portfolio.png";
import annexeGoweb from "./assets/goweb-maquettes.png";
import dataflow from "./assets/dataflow.jpg";
import snakeGif from "./assets/snake.gif";
import excel from "./assets/excel.png";
import linguacards from "./assets/linguacards.jpg";

const projects = [
  {
    tag: "portfolio",
    name: "Portfolio - Site Perso",
    technos: ["React JS"],
    image: portfolio,
    links: [],
    description: `Site sur lequel nous nous trouvons actuellement ! üòâ`,
  },
  {
    tag: "goweb",
    name: "QuickRepair (Test Technique) ",
    technos: ["Node JS", "React JS"],
    image: goweb,
    links: [
      {
        text: "Repo GitHub",
        url: "https://github.com/antoine-gpn/Quick-Repair",
      },
      {
        text: "Acc√®s au site",
        url: "https://quick-repair.antoine-grappin.fr/",
      },
    ],
    description: `Ce projet a √©t√© r√©alis√© dans le cadre d'un test technique pour une entreprise de la m√©tropole lilloise. Le but √©tait de r√©aliser une solution FullStack de d√©pannage en ligne (plomberie, √©lectrom√©nager‚Ä¶) avec une libert√© totale dans le choix des techno Front et Back. Pour cela, deux ressources √©taient fournies : des maquettes Figma √† reproduire le plus fid√®lement possible ainsi qu'un fichier Excel donnant l'arborescence des choix disponibles. 
    
    Puisque l'entreprise pour laquelle √©tait destin√© ce test √©tait tr√®s orient√©e JavaScript, j'ai choisi NodeJS et React pour la Stack Technique. L'id√©e dans un premier temps, fut de reproduire l'arborescence des choix de d√©pannage au format JSON pour l'exploiter plus facilement. J'ai ensuite r√©alis√© l'API NodeJS avec deux routes : l'une renvoie le parcours de d√©pannage en JSON et l'autre permet l'envoi d'un mail r√©capitualif √† la fin du formulaire. Enfin, une fois le Back termin√©, j'ai pu reproduire les maquettes Figma sur React en d√©coupant l'appli en 4 composants (L'onboarding => Page d'accueil, L'interface de choix multiple suivant, puis enfin, les deux pages de r√©capitualif dont la derni√®re comprend un formulaire pour que le client soit rencontact√©.
`,
    annexes: [annexeGoweb, excel],
  },
  {
    tag: "dataflow-iot",
    name: "Dataflow-IOT",
    technos: ["Angular", "Node JS", "Mongo DB"],
    image: dataflow,
    links: [
      {
        text: "Repo GitHub",
        url: "https://github.com/antoine-gpn/dataflow-iot",
      },
      {
        text: "Acc√®s au site",
        url: "https://dataflow-iot.antoine-grappin.fr/",
      },
    ],
    description: `Le projet Dataflow-IOT est n√© de la refonte d'un projet que j'avais d√ª r√©aliser dans le cadre d'un test technique pour une alternance. 
Il √©tait √† l'√©poque r√©alis√© uniquement avec Symfony mais j'ai fait le choix de faire une refonte visuelle via Angular 17.

L'intitul√© du test √©tait de cr√©er un Dahsboard simple permettant √† un utilisateur de visualiser les donn√©es de ses diff√©rents objets connect√©s (IOT).
L'interface se compose simplement d'une liste d'appareil connect√©s (montres, ampoules‚Ä¶) ainsi que d'un r√©cap des donn√©es par temporalit√© (jour, semaine, mois‚Ä¶).

Le graphique est g√©n√©r√© via la Library D3.js et le stockage des donn√©es via une base Mongo DB h√©berg√©e chez OVH Cloud.
`,
  },
  {
    tag: "snake",
    name: "Snake GUI",
    technos: ["Python"],
    image: snake,
    links: [
      { text: "Repo GitHub", url: "https://github.com/antoine-gpn/Snake" },
    ],
    description: `Le projet Snake a √©t√© r√©alis√© sur mon temps libre pour me familiariser avec les interfaces graphiques utilisateur (GUI). Pour cela, j‚Äôai d√©cid√© de m‚Äôorienter vers Python puisque de nombreuses librairies permettent de r√©aliser ce genre de projet avec un code de d√©part plut√¥t l√©ger et donc facile √† prendre en main. Je me suis orient√© vers Tkinter, l‚Äôune des librairies graphiques les plus populaires dans la communaut√© Python. 

Une fois la technologie trouv√©e, il me fallait une id√©e de projet. J‚Äôai rapidement choisi le jeu Snake puisque les r√®gles sont assez simples mais permettent d'appr√©hender divers param√®tres challengeants d‚Äôun point de vue visuel.

J‚Äôai d‚Äôabord cr√©√© une interface compos√©e d‚Äôun damier de 10x10 cases et cod√© les fonctions permettant de g√©n√©rer le serpent et la pomme. Il a ensuite fallu coder les d√©placements et l'agrandissement du serpent, l‚Äôapparition al√©atoire de la pomme √† chaque contact avec le serpent et l‚Äôimpl√©mentation du Game Over. Sans rentrer dans les d√©tails, les positions du corps du serpent sont repr√©sent√©es sous forme de tableau de tuples (x, y) indiquant la position de chaque carr√© composant le serpent au format abscisse/ordonn√©e : [ (1 , 1) , (1 , 2) ... ]
`,
    annexes: [snakeGif],
  },
  {
    tag: "linguacards",
    name: "LinguaCards (A venir)",
    technos: ["Java Spring", "AngularJS", "MongoDB"],
    image: linguacards,
    links: [,],
    description: `Le projet LinguaCards est n√© de la volont√© de trouver la solution la plus optimale et ludique possible pour apprendre une langue (dans mon cas personnel, l‚Äôobjectif √©tait de peaufiner mon niveau en anglais). Pour cela, j‚Äôai d√©cid√© de m‚Äôappuyer sur un syst√®me d‚Äôapprentissage nomm√© SRS (Spaced Repetition System). Ce syst√®me a pour but de r√©p√©ter la m√©morisation d‚Äôun concept (en l'occurrence, il s‚Äôagit ici de mots de vocabulaire).

L‚Äôid√©e est d‚Äô√™tre confront√© √† un mot de mani√®re r√©guli√®re pour le faire passer de la m√©moire √† court terme vers la m√©moire √† long terme. Afin de rendre l‚Äôapprentissage ludique, j‚Äôai d√©cid√© de regrouper ces mots sous la forme d‚Äôun deck de cartes recto-verso compos√© du mot dans la langue de l‚Äôutilisateur ainsi que sa traduction dans la langue souhait√©e. Chaque carte aura alors un score non visible associ√© permettant de l'associer √† l‚Äôune des 3 cat√©gories : "court-terme", "moyen-terme" et "long-terme". 

Le ‚Äújeu‚Äù de m√©morisation s‚Äôapparentera alors √† une page sur laquelle figure le deck dont la premi√®re carte sera retourn√©e. L‚Äôutilisateur devra deviner la traduction du mot affich√© et devra swipe √† gauche ou √† droite en fonction de s‚Äôil a pu trouver la bonne r√©ponse ou non. Cette action affecte le score de la carte concern√©e, d√©finissant ainsi le temps n√©cessaire avant que la carte se pr√©sentera √† nouveau √† l‚Äôutilisateur.

De plus, dans un but de rendre l'appliciation ludique, une image illustera chaque carte. Celle-ci sera g√©n√©r√©e via un appel vers l'API du site Freepik (une API externe g√©n√©rant une image via IA selon un prompt donn√© qui sera ici le mot de vocabulaire). De la m√™me mani√®re, lorsque l'utilisateur voudra ajouter une nouvelle carte, il aura simplement √† saisir le mot dans l'une des deux langues, la traduction sera automatiquement propos√© √† l'aide d'un appel vers l'API de Google Translate.

Enfin, chaque personne voulant utiliser ce service devra cr√©er un compte en arrivant sur la plateforme. La gestion de l'utilisateur se fera via Spring Security c√¥t√© Back-end et fonctionnera avec un syst√®me de Json Web Token pour g√©rer les acc√®s √† l'API. Le stockage des donn√©es utilisateur sera s√©curis√© avec un cryptage du mot de passe avant d'√™tre stock√© dans la base MongoDB.
`,
  },
];

export default projects;
